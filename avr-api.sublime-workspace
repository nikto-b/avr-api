{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"_usart0_tx",
				"_usart0_txbuf_len_end"
			],
			[
				"_usart",
				"_usart0_txbuf_len_end"
			],
			[
				"_usart0_txb",
				"_usart0_txbuf_len_start"
			],
			[
				"St",
				"stringFuncs"
			],
			[
				"usart",
				"usartInBuf"
			],
			[
				"usa",
				"usartInBuf"
			],
			[
				"par",
				"parseInputCmds"
			],
			[
				"rec",
				"recvUsart"
			],
			[
				"_arr",
				"_arrLen"
			],
			[
				"usartIn",
				"usartInBufCounter"
			],
			[
				"USAR",
				"USART0Println"
			],
			[
				"USART",
				"USART0Println"
			],
			[
				"USA",
				"USART0Send"
			],
			[
				"uit",
				"uint8_t"
			],
			[
				"get",
				"getCountsOfDigits"
			],
			[
				"TIMER0_WF_F",
				"TIMER0_WF_FPWM_TOPOCR0A\t(TimerModes_2560.h)"
			],
			[
				"TIMER0_COMB_FPWM",
				"TIMER0_COMB_FPWM_NORMAL\t(TimerModes_2560.h)"
			],
			[
				"TIMER3_WF_FPWM_",
				"TIMER3_WF_FPWM_10B\t(TimerModes_2560.h)"
			],
			[
				"WD",
				"USE_WATCHDOG"
			],
			[
				"ne",
				"nextInt"
			]
		]
	},
	"buffers":
	[
		{
			"file": "USART.c",
			"settings":
			{
				"buffer_size": 8030,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "main.cpp",
			"settings":
			{
				"buffer_size": 802,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "Timers.c",
			"settings":
			{
				"buffer_size": 16277,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "TimerModes_2560.h",
			"settings":
			{
				"buffer_size": 31998,
				"line_ending": "Unix"
			}
		},
		{
			"file": "USART.h",
			"settings":
			{
				"buffer_size": 1019,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "Packages/Java/JavaC.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Java/Ant.sublime-build",
					""
				],
				[
					"Packages/Java/JavaC.sublime-build",
					""
				]
			],
			[
				"Packages/Java/JavaC.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"toggle",
				"View: Toggle Menu"
			],
			[
				"toggle ",
				"View: Toggle Menu"
			],
			[
				"toggle me",
				"View: Toggle Menu"
			],
			[
				"autosa",
				"Toggle AutoSave: all files"
			],
			[
				"package",
				"Preferences: Browse Packages"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"men",
				"View: Toggle Menu"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"side",
				"View: Toggle Side Bar"
			],
			[
				"autosave",
				"Toggle AutoSave: all files"
			],
			[
				"menu",
				"View: Toggle Menu"
			],
			[
				"git",
				"GitGutter: Disable for View"
			],
			[
				"tab",
				"View: Toggle Tabs"
			],
			[
				"bar",
				"View: Toggle Side Bar"
			],
			[
				"stat",
				"View: Toggle Status Bar"
			],
			[
				"tabs",
				"View: Toggle Tabs"
			],
			[
				"sidebar",
				"View: Toggle Side Bar"
			],
			[
				"status bar",
				"View: Toggle Status Bar"
			],
			[
				"Package Control: insta",
				"Package Control: Install Package"
			],
			[
				"Package Control: remo",
				"Package Control: Remove Package"
			],
			[
				"package control remo",
				"Package Control: Remove Package"
			],
			[
				"package control disa",
				"Package Control: Disable Package"
			],
			[
				"package control ena",
				"Package Control: Enable Package"
			],
			[
				"package control insta",
				"Package Control: Install Package"
			],
			[
				"Package Control: re",
				"Package Control: Remove Package"
			],
			[
				"Package Control: remove",
				"Package Control: Remove Package"
			],
			[
				"package control e",
				"Package Control: Enable Package"
			],
			[
				"package control",
				"Package Control: Disable Package"
			],
			[
				"package control li",
				"Package Control: List Packages"
			],
			[
				"package control Disa",
				"Package Control: Disable Package"
			],
			[
				"package control list",
				"Package Control: List Packages"
			],
			[
				"Package Control: ",
				"Package Control: List Packages"
			],
			[
				"Package Control: ena",
				"Package Control: Enable Package"
			],
			[
				"Pac",
				"Package Control: Enable Package"
			],
			[
				"Package",
				"Package Control: Disable Package"
			],
			[
				"Package Control: disa",
				"Package Control: Disable Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 125.0,
		"history":
		[
			"show all",
			"show",
			"show statusbar",
			"terminality",
			"terminal",
			"packet control: list packets",
			"packet control list",
			"packet control",
			"restart",
			"reset",
			"clear",
			"?",
			"h",
			"-h",
			"help",
			"goto",
			"goro",
			"loop",
			"make",
			"zsh",
			"cd"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/nikto_b/Documents/C++/avr-api"
	],
	"file_history":
	[
		"/home/nikto_b/Documents/C++/avr-api/TimerModes_2560.h",
		"/home/nikto_b/Documents/C++/avr-api/Timers.h",
		"/home/nikto_b/Documents/C++/avr-api/Timers.c",
		"/home/nikto_b/Documents/C++/avr-api/api.h",
		"/home/nikto_b/Documents/C++/avr-api/main.cpp",
		"/home/nikto_b/Documents/C++/avr-api/customFuncAddr.h",
		"/home/nikto_b/Documents/C++/avr-api/ADC.h",
		"/home/nikto_b/Documents/C++/avr-api/ADC.c",
		"/home/nikto_b/Documents/C++/avr-api/main.cpp.bak",
		"/home/nikto_b/Documents/C++/avr-api/digitalRegisters.c",
		"/home/nikto_b/Documents/C++/avr-api/digitalRegisters.h",
		"/home/nikto_b/Documents/C++/avr-api/Makefile",
		"/home/nikto_b/Documents/C++/avr-api/customFuncAddr.c",
		"/home/nikto_b/Documents/C++/avr-api/main.cpp.bak2",
		"/home/nikto_b/Documents/C++/avr-api/USART.h",
		"/home/nikto_b/Documents/C++/avr-api/stringFuncs.h",
		"/home/nikto_b/Documents/C++/avr-api/stringFuncs.c",
		"/home/nikto_b/Documents/C++/avr-api/USART.c",
		"/home/nikto_b/Documents/C++/avr-api/watchdog.c",
		"/home/nikto_b/Documents/C++/avr-api/settings.h",
		"/home/nikto_b/Documents/C++/avr-api/base.h",
		"/home/nikto_b/Documents/C++/avr-api/ADCModes.h",
		"/home/nikto_b/Documents/C++/avr-api/watchdogModes.h",
		"/home/nikto_b/Documents/C++/avr-api/watchdog.h",
		"/home/nikto_b/Documents/C++/avr-api/avr-api.sublime-project",
		"/home/nikto_b/C++/avr-api/main.cpp",
		"/home/nikto_b/.config/sublime-text-3/Packages/User/intellitip.sublime-settings",
		"/home/nikto_b/.config/sublime-text-3/Packages/Intellitip/intellitip.sublime-settings",
		"/home/nikto_b/C++/avr-api/Timers.h",
		"/home/nikto_b/C++/avr-api/Timer.c.old",
		"/home/nikto_b/C++/avr-api/TimerModes_2560.h",
		"/home/nikto_b/C++/avr-api/Timers.c",
		"/home/nikto_b/C++/avr-api/Makefile",
		"/home/nikto_b/C++/avr-api/stringFuncs.c",
		"/home/nikto_b/C++/avr-api/api.h",
		"/home/nikto_b/C++/avr-api/avr-api.sublime-project",
		"/home/nikto_b/C++/avr-api/TimerModes_2560.h.old",
		"/home/nikto_b/C++/avr-api/main.d",
		"/home/nikto_b/C++/avr-api/main.eep",
		"/home/nikto_b/C++/avr-api/main.elf",
		"/home/nikto_b/C++/avr-api/main.hex",
		"/home/nikto_b/Arduino/sketch_dec02a/sketch_dec02a.ino",
		"/home/nikto_b/C++/avr-api/watchdogModes.h",
		"/home/nikto_b/C++/avr-api/watchdog.h",
		"/home/nikto_b/C++/avr-api/watchdog.c",
		"/home/nikto_b/.config/sublime-text-3/Packages/Terminal/Default (Linux).sublime-keymap",
		"/home/nikto_b/C++/avr-api/.gitignore",
		"/home/nikto_b/C++/avr-api/USARTModes.h",
		"/home/nikto_b/C++/avr-api/USART.h",
		"/home/nikto_b/C++/avr-api/USART.c",
		"/home/nikto_b/C++/avr-api/stringFuncs.h",
		"/home/nikto_b/C++/avr-api/settings.h",
		"/home/nikto_b/C++/avr-api/FuncsInputProtector.h",
		"/home/nikto_b/C++/avr-api/FuncsInputProtector.c",
		"/home/nikto_b/C++/avr-api/digitalRegisters.h",
		"/home/nikto_b/C++/avr-api/digitalRegisters.c",
		"/home/nikto_b/C++/avr-api/ADCModes.h",
		"/home/nikto_b/C++/avr-api/ADC.h",
		"/home/nikto_b/C++/avr-api/ADC.c",
		"/home/nikto_b/.config/sublime-text-3/Packages/Terminality/README.md",
		"/home/nikto_b/C++/avr-api/delayMicroseconds.c",
		"/home/nikto_b/C++/avr-api/customFuncAddr.h",
		"/home/nikto_b/C++/avr-api/customFuncAddr.c",
		"/home/nikto_b/.config/sublime-text-3/Packages/All Autocomplete/All Autocomplete.sublime-settings",
		"/home/nikto_b/.config/sublime-text-3/Packages/User/All Autocomplete.sublime-settings",
		"/home/nikto_b/.config/sublime-text-3/Packages/Package Control/Package Control.sublime-settings",
		"/home/nikto_b/IdeaProjects/untitled1/src/Program.java",
		"/home/nikto_b/IdeaProjects/untitled1/src/[path",
		"/home/nikto_b/.config/sublime-text-3/Packages/User/javac+java.sublime-build",
		"/home/nikto_b/4.10. MiniProject/src/com/example/DBMatches/DBMatches.java",
		"/home/nikto_b/Downloads/Program.java"
	],
	"find":
	{
		"height": 39.8803589232
	},
	"find_in_files":
	{
		"height": 102.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"TIMMER",
			"TIMER3_WF_FPWM",
			"TIMER2_WF_",
			"__N__",
			"4",
			"_CLK_SRC_1",
			"_PWM_PHFC_",
			"_FPWM_",
			"TIMER1_COM",
			"TIMER1SetB",
			"TIMER1_WF_FPWM",
			"_WF_FPWM_",
			"TIEMER",
			"TEIMER",
			"ADCGetAnalogChanged",
			"enable",
			"inline",
			"USE",
			"inline",
			"inline ",
			"__N__",
			"0",
			"_N_",
			"0",
			"PWM",
			"scheduleAddFunc",
			"']')))",
			"0",
			"A",
			"string",
			"string ",
			"hex",
			"]);\n",
			"Phase Correct PWM Mode(",
			"clock select",
			"disconnected",
			"Desc",
			"what",
			"what time will turn",
			"MOTOR_DIR",
			"MOTOR_SPD",
			"define",
			"0",
			"DESCEND_MAN",
			"ELEVATE_MAN",
			"RETRACT_MAN",
			"EXT_MAN",
			"dd",
			"\n\n\n\n",
			"fucking",
			"#include <avr/io.h>\t\t\t//include for base avr funcs\n#define F_CPU 16000000\t\t//define with freq\n#include <util/delay.h> \t//include for delay func\n#include <avr/interrupt.h>\t//include interrupt funcs\n#include <stdlib.h>\n\n#define NUM_OF_ANALOG_PINS 7\n#define ARDUINO_SUPPORT 0\n#define USE_FUNC_INPUT_PROTECTOR 0\n\n//-----------ADC-----------\n#define USE_ADC 1\n#define USE_ADC_8BIT 1\n#define ADC_MODE ADC_MODE_DEADLINE\n#define ADC_DEF_PRESCALLER ADC_PRESCALLER_128\n\n//---------TIMERS----------\n#define USE_TIMERS 1\n#define TIMER0_USE_COMPA 1\n#define TIMER5_USE_COMPA 1\n#define TIMER3_USE_COMPA 1\n\n//---------USART----------\n#define EOL \"\\n\\r\"\n#define USE_USART 1\n#define USE_USART0 1\n#define USE_USART0_OUTPUT 1\n#define USE_USART0_INPUT 1\n#define USE_SERIAL_FASTBAUD 0\n\n//---------CUSTOM_INTERRUPTS----------\n#define USE_CUSTOM_INTERRUPTS 1\n\n\n#define USE_WATCHDOG 1\n\n#include \"./api.h\"//custom lib for AVR\n#define DEBUG\t\t\t\t\t0\n\n#define _TWI_ACK\t\t\t\t1\n#define _TWI_NACK\t\t\t\t0\n#define _TWI_MASTER_BUF_LEN\t\t255\n#define _TWI_IN_BUF_LEN\t\t\t255\n#define _TWI_OUT_BUF_LEN\t\t255\n#define I2C_WRITE\t\t\t\t0\n#define I2C_READ\t\t\t\t1\n#define I2C_STANDBY\t\t\t\t2\n#define I2C_FAIL\t\t\t\t3\n\n/*************************** REGISTER MAP ***************************/\n#define ADXL345_DEVID\t\t\t0x00\t\t// Device ID\n#define ADXL345_RESERVED1\t\t0x01\t\t// Reserved. Do Not Access. \n#define ADXL345_THRESH_TAP\t\t0x1D\t\t// Tap Threshold. \n#define ADXL345_OFSX\t\t\t0x1E\t\t// X-Axis Offset. \n#define ADXL345_OFSY\t\t\t0x1F\t\t// Y-Axis Offset.\n#define ADXL345_OFSZ\t\t\t0x20\t\t// Z- Axis Offset.\n#define ADXL345_DUR\t\t\t\t0x21\t\t// Tap Duration.\n#define ADXL345_LATENT\t\t\t0x22\t\t// Tap Latency.\n#define ADXL345_WINDOW\t\t\t0x23\t\t// Tap Window.\n#define ADXL345_THRESH_ACT\t\t0x24\t\t// Activity Threshold\n#define ADXL345_THRESH_INACT\t0x25\t\t// Inactivity Threshold\n#define ADXL345_TIME_INACT\t\t0x26\t\t// Inactivity Time\n#define ADXL345_ACT_INACT_CTL\t0x27\t\t// Axis Enable Control for Activity and Inactivity Detection\n#define ADXL345_THRESH_FF\t\t0x28\t\t// Free-Fall Threshold.\n#define ADXL345_TIME_FF\t\t\t0x29\t\t// Free-Fall Time.\n#define ADXL345_TAP_AXES\t\t0x2A\t\t// Axis Control for Tap/Double Tap.\n#define ADXL345_ACT_TAP_STATUS\t0x2B\t\t// Source of Tap/Double Tap\n#define ADXL345_BW_RATE\t\t\t0x2C\t\t// Data Rate and Power mode Control\n#define ADXL345_POWER_CTL\t\t0x2D\t\t// Power-Saving Features Control\n#define ADXL345_INT_ENABLE\t\t0x2E\t\t// Interrupt Enable Control\n#define ADXL345_INT_MAP\t\t\t0x2F\t\t// Interrupt Mapping Control\n#define ADXL345_INT_SOURCE\t\t0x30\t\t// Source of Interrupts\n#define ADXL345_DATA_FORMAT\t\t0x31\t\t// Data Format Control\n#define ADXL345_DATAX0\t\t\t0x32\t\t// X-Axis Data 0\n#define ADXL345_DATAX1\t\t\t0x33\t\t// X-Axis Data 1\n#define ADXL345_DATAY0\t\t\t0x34\t\t// Y-Axis Data 0\n#define ADXL345_DATAY1\t\t\t0x35\t\t// Y-Axis Data 1\n#define ADXL345_DATAZ0\t\t\t0x36\t\t// Z-Axis Data 0\n#define ADXL345_DATAZ1\t\t\t0x37\t\t// Z-Axis Data 1\n#define ADXL345_FIFO_CTL\t\t0x38\t\t// FIFO Control\n#define ADXL345_FIFO_STATUS\t\t0x39\t\t// FIFO Status\n\n#define ADXL345_BW_1600\t\t\t0xF\t\t\t// 1111\t\tIDD = 40uA\n#define ADXL345_BW_800\t\t\t0xE\t\t\t// 1110\t\tIDD = 90uA\n#define ADXL345_BW_400\t\t\t0xD\t\t\t// 1101\t\tIDD = 140uA\n#define ADXL345_BW_200\t\t\t0xC\t\t\t// 1100\t\tIDD = 140uA\n#define ADXL345_BW_100\t\t\t0xB\t\t\t// 1011\t\tIDD = 140uA \n#define ADXL345_BW_50\t\t\t0xA\t\t\t// 1010\t\tIDD = 140uA\n#define ADXL345_BW_25\t\t\t0x9\t\t\t// 1001\t\tIDD = 90uA\n#define ADXL345_BW_12_5\t\t    0x8\t\t\t// 1000\t\tIDD = 60uA \n#define ADXL345_BW_6_25\t\t\t0x7\t\t\t// 0111\t\tIDD = 50uA\n#define ADXL345_BW_3_13\t\t\t0x6\t\t\t// 0110\t\tIDD = 45uA\n#define ADXL345_BW_1_56\t\t\t0x5\t\t\t// 0101\t\tIDD = 40uA\n#define ADXL345_BW_0_78\t\t\t0x4\t\t\t// 0100\t\tIDD = 34uA\n#define ADXL345_BW_0_39\t\t\t0x3\t\t\t// 0011\t\tIDD = 23uA\n#define ADXL345_BW_0_20\t\t\t0x2\t\t\t// 0010\t\tIDD = 23uA\n#define ADXL345_BW_0_10\t\t\t0x1\t\t\t// 0001\t\tIDD = 23uA\n#define ADXL345_BW_0_05\t\t\t0x0\t\t\t// 0000\t\tIDD = 23uA\n\n\n /************************** INTERRUPT PINS **************************/\n#define ADXL345_INT1_PIN\t\t0x00\t\t//INT1: 0\n#define ADXL345_INT2_PIN\t\t0x01\t\t//INT2: 1\n\n\n /********************** INTERRUPT BIT POSITION **********************/\n#define ADXL345_INT_DATA_READY_BIT\t\t0x07\n#define ADXL345_INT_SINGLE_TAP_BIT\t\t0x06\n#define ADXL345_INT_DOUBLE_TAP_BIT\t\t0x05\n#define ADXL345_INT_ACTIVITY_BIT\t\t0x04\n#define ADXL345_INT_INACTIVITY_BIT\t\t0x03\n#define ADXL345_INT_FREE_FALL_BIT\t\t0x02\n#define ADXL345_INT_WATERMARK_BIT\t\t0x01\n#define ADXL345_INT_OVERRUNY_BIT\t\t0x00\n\n#define ADXL345_DATA_READY\t\t\t\t0x07\n#define ADXL345_SINGLE_TAP\t\t\t\t0x06\n#define ADXL345_DOUBLE_TAP\t\t\t\t0x05\n#define ADXL345_ACTIVITY\t\t\t\t0x04\n#define ADXL345_INACTIVITY\t\t\t\t0x03\n#define ADXL345_FREE_FALL\t\t\t\t0x02\n#define ADXL345_WATERMARK\t\t\t\t0x01\n#define ADXL345_OVERRUNY\t0x00\n\n\n//system vars\nvolatile uint8_t _twi_master_buf [_TWI_MASTER_BUF_LEN];\nvolatile uint8_t _twi_master_len\t\t= 0;\nvolatile uint8_t _twi_initial_packet\t= 0;\nvolatile uint8_t _twi_tx_len\t\t\t= 0;\nvolatile uint8_t _twi_rx_len\t\t\t= 0;\n\n//input  vars\nvolatile uint8_t _twi_in_buf\t [_TWI_IN_BUF_LEN];\nvolatile uint8_t _twi_in_lens_buf[_TWI_IN_BUF_LEN];\nvolatile uint8_t _twi_in_len \t\t\t= 0;\nvolatile uint8_t _twi_in_lens_len \t\t= 0;\n\n//output vars\nvolatile uint8_t _twi_out_buf\t [_TWI_OUT_BUF_LEN];\nvolatile uint8_t _twi_out_lens_buf[_TWI_OUT_BUF_LEN];\nvolatile uint8_t _twi_out_len\t\t\t= 0;\nvolatile uint8_t _twi_out_lens_len\t \t= 0;\n\nvolatile uint8_t _twi_err\t\t\t\t= 0;\n\nvolatile int16_t _r16\t\t\t\t\t= 0;\nvolatile uint8_t _twi_status\t\t\t= I2C_STANDBY;\n\n/*\n * Function I2C_SetFreq\n * Desc     Set working frequency of I2C bus\n * Input    _freq: what frequency set to\n * Output   none\n*/\nvoid I2C_SetFreq(uint8_t _freq)\n{\n\tTWBR = _freq;\n}\n\nuint8_t I2C_GetError(void)\n{\n\treturn _twi_err;\n}\n\nvoid I2C_SetRxLen(uint8_t _len)\n{\n\t_twi_rx_len = _len;\n}\n\n/*\n * Function _twi_start\n * Desc     Send start to TWI and do some buffer-cpy work\n * Input    none\n * Output   none\n*/\nvoid _twi_start(void)\n{\n\t#if DEBUG == 1\n\t\tUSART0Println(\"start\");\n\t\tUSART0Print(\"len:\");\n\t\tUSART0Println(_twi_in_lens_buf[_twi_in_lens_len - 1]);\n\t\tUSART0Print(\"init:\");\n\t\tUSART0Println(_twi_in_buf[0]);\n\t#endif\n\tif(_twi_status == I2C_STANDBY\n\t|| _twi_status == I2C_FAIL)\n\t{\n\t\t_twi_initial_packet = _twi_in_buf[0];\n\t\t#if DEBUG == 1\n\t\t\tUSART0Print(\"init\");\n\t\t\tUSART0Println(_twi_initial_packet);\n\t\t#endif\n\t\t_twi_status = (_twi_initial_packet & 1)? I2C_READ : I2C_WRITE;//I2C_READ if true, I2C_WRITE if false\n\t\t\t\t\t\t\t\t\t\t\t\t//because _twi_initial_packet = (slave_addr << 1) | (1 if READ, 0 if WRITE)\n\t\t#if DEBUG == 1\n\t\t\tUSART0Print(\"s \");\n\t\t\tUSART0Print((_twi_status == 1)? \"READ\" : \"WRITE\");\n\t\t\tUSART0Println();\n\t\t#endif //if DEBUG == 1\n\t\t//if(_twi_status == I2C_WRITE)\n\t\t//{\n\t\t\t_twi_tx_len = _twi_in_lens_buf[_twi_in_lens_len - 1] - 1;\n\t\t\t#if DEBUG == 1\n\t\t\t\tUSART0Println(_twi_tx_len);\n\t\t\t#endif //if DEBUG == 1\n\t\t//}\n\t\tif(_twi_status == I2C_WRITE)\n\t\t{\n\t\t\tfor(int i = 0; i < _twi_tx_len; i++)\n\t\t\t{\n\t\t\t\t_twi_master_buf[i] = _twi_in_buf[i + 1];\n\t\t\t\t#if DEBUG == 1\n\t\t\t\t\tUSART0Print(\"set \");\n\t\t\t\t\tUSART0Print(_twi_master_buf[i]);\n\t\t\t\t\tUSART0Print(\" to \");\n\t\t\t\t\tUSART0Println(i);\n\t\t\t\t#endif\n\t\t\t\t_twi_in_buf[i] = _twi_in_buf[i + _twi_tx_len + 1];\t\t//MORE OPTIMIZATIONS!!!\n\t\t\t}\n\t\t}\n\t\telse if(_twi_status == I2C_READ)\n\t\t{\n\t\t\t_twi_rx_len = _twi_in_buf[1];\n\t\t\t_twi_tx_len = 0;\n\t\t\t_twi_in_len -= 1;\n\t\t\tfor(int i = 0; i < _twi_in_len - 1; i++)\n\t\t\t{\n\t\t\t\t_twi_in_buf[i] = _twi_in_buf[i + 2];\n\t\t\t}\n\t\t}\n\t\tfor(int i = _twi_tx_len; i < _twi_in_len; i++)\n\t\t{\n\t\t\t_twi_in_buf[i] = _twi_in_buf[i + _twi_in_lens_buf[_twi_in_lens_len - 1]];\n\t\t}\n\t\t_twi_in_len -= _twi_tx_len + 1;\n\t\t_twi_master_len = 0;\n\t\t_twi_in_lens_len--;\n\t\tfor(int i = 0; i <= _twi_in_lens_len; i++)\n\t\t{\n\t\t\t_twi_in_lens_buf[i] = _twi_in_lens_buf[i + 1];\n\t\t}\n\t\tTWCR = (1 << TWSTA) | (1 << TWINT) | (1 << TWEN) | (1 << TWIE);//sent start, enable interrupt, enable TWI\n\t}\n\telse\n\t{\n\t\tUSART0Print(\"start fail\\n\\rstatus:\");\n\t\tUSART0Println(_twi_status);\n\t}\n}\n\n/*\n * Function _twi_stop\n * Desc     Sendstop to TWI and copy recieved bytes if have\n * Input    none\n * Output   none\n*/\nvoid _twi_stop(void)\n{\n\tTWCR = (1 << TWEN) | (1 << TWIE) | (1 << TWINT) | (1 << TWSTO);\n\t#if DEBUG == 1\n\t\tUSART0Println(\"stop\");\n\t\tUSART0Print(\"M:\");\n\t\tUSART0Println((char*)(((_twi_initial_packet & 1) == 1)? \"R\" : \"W\"));\n\t#endif\n\tif(_twi_status == I2C_READ)\n\t{\n\t\t#if DEBUG == 1\n\t\t\tUSART0Println(_twi_master_buf[0]);\n\t\t\tUSART0Print(\"twol \");\n\t\t\tUSART0Print(_twi_out_len);\n\t\t\tUSART0Print(\"twml \");\n\t\t\tUSART0Println(_twi_master_len);\n\t\t#endif //if DEBUG == 1\n\t\tfor(int i = _twi_out_len; i <= _twi_out_len + (_twi_rx_len); i++)\n\t\t{\n\t\t\t//_twi_master_len--;\n\t\t\t#if DEBUG == 1\n\t\t\t\tUSART0Print(\"i:\");\n\t\t\t\tUSART0Println(i);\n\t\t\t\tUSART0Print(\"outlen:\");\n\t\t\t\tUSART0Println(_twi_out_len);\n\t\t\t#endif //if DEBUG == 1\n\t\t\t_twi_out_buf[i] = _twi_master_buf[i - _twi_out_len];\n\t\t}\n\t\t_twi_out_len += _twi_rx_len;\n\t\t#if DEBUG == 1\n\t\t\tUSART0Println(_twi_out_buf[0]);\n\t\t\tUSART0Println(_twi_out_len);\n\t\t#endif //if DEBUG == 1\n\t}\n\tif(_twi_status != I2C_FAIL)\n\t{\n\t\t_twi_status = I2C_STANDBY;\n\t}\n\tif(_twi_in_len != 0)\n\t{\n\t\tif(_twi_status != I2C_FAIL)\n\t\t{\n\t\t\t#if DEBUG == 1\n\t\t\t\tUSART0Println(\"pst\");\t\n\t\t\t#endif //if DEBUG == 1\n\t\t\t_twi_start();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUSART0Println(\"pst fail\\ncleanup...\");\n\t\t\t_twi_in_len = 0;\n\t\t\t_twi_in_lens_len--;\n\t\t}\n\t}\n}\n\n/*\n * Function _twi_reply\n * Desc     Send reply on I2C(ACK or NACK)\n * Input    _ack: send ACK or NACK\n * Output   none\n*/\nvoid _twi_reply(uint8_t _ack)\n{\n\tif(_ack)\n\t{\n\t\tTWCR = (1 << TWEN) | (1 << TWIE) | (1 << TWINT) | (1 << TWEA);\n\t}\n\telse\n\t{\n\t\tTWCR = (1 << TWEN) | (1 << TWIE) | (1 << TWINT);\n\t}\n}\n\n/*\n * Function I2C_Write\n * Desc     Send byte to TWI buf for transfering to I2C bus\n * Input    _in: byte to transfer\n * Output   none\n*/\nvoid I2C_Write(uint8_t _in)\n{\n\t#if DEBUG == 1\n\t\tUSART0Print(\"send \");\n\t\tUSART0Print(_in);\n\t\tUSART0Print(\" to \");\n\t\tUSART0Println(_twi_in_len);\n\t#endif //if DEBUG == 1\n\t_twi_in_buf[_twi_in_len] = _in;\n\t_twi_in_len++;\n\t_twi_in_lens_buf[_twi_in_lens_len - 1]++;\n}\n\n/*\n * Function I2C_Read\n * Desc\t\tRead recieved byte from iic, \n * \t\t\twait if have no recieved but \n * \t\t\tTWI working. ret 0 if no data \n * \t\t\tin buf or TWI fail\n * Input\tnone\n * Output\tnone\n*/\nuint8_t I2C_Read(void)\n{\n\t#if DEBUG == 1\n\t\tUSART0Println(\"I2C_READ\");\n\t\tUSART0Print(\"outlen:\");\n\t\tUSART0Println(_twi_out_len);\n\t\tUSART0Print(\"stat:\");\n\t\tUSART0Println(_twi_status);\n\t#endif //if DEBUG == 1\n\tcli();\n\tif((_twi_out_len > 0) || (_twi_out_len == 0 && _twi_status != I2C_STANDBY))\n\t{\n\t\t//#if DEBUG == 1\n\t\t\t//USART0Println(\"WAIT\");\n\t\t\t//USART0Println(_twi_status);\n\t\t\t//USART0Println(_twi_out_len);\n\t\t\t//USART0Println(_twi_out_buf[0]);\n\t\t\t//USART0Println(_twi_out_buf[1]);\n\t\t\t//USART0Println(_twi_out_buf[2]);\n\t\t\t//USART0Println(_twi_out_buf[_twi_out_len]);\n\t\t//#endif //if DEBUG == 1\n\t\twhile(_twi_out_len == 0 && _twi_status != I2C_STANDBY)\n\t\t{\n\t\t\tsei();\n\t\t\tif(_twi_status == I2C_FAIL)\n\t\t\t{\n\t\t\t\t//#if DEBUG == 1\n\t\t\t\t\tUSART0Println(\"F1\");\n\t\t\t\t//#endif //if DEBUG == 1\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}//wait for byte\n\t\tif(_twi_out_len != 0 && _twi_status == I2C_STANDBY)\n\t\t{\n\t\t\t#if DEBUG == 1\n\t\t\t\tfor(int i = 0; i < 8; i++)\n\t\t\t\t{\n\t\t\t\t\tUSART0Print(i);\n\t\t\t\t\tUSART0Print(\" \");\n\t\t\t\t\tUSART0Println(_twi_out_buf[i]);\n\t\t\t\t}\n\t\t\t#endif //if DEBUG == 1\n\t\t\tuint8_t _res = _twi_out_buf[0];\n\t\t\t_twi_out_len--;\n\t\t\tfor(int i = 0; i <= _twi_out_len; i++)\n\t\t\t{\n\t\t\t\t_twi_out_buf[i] = _twi_out_buf[i + 1];\n\t\t\t}\n\t\t\treturn _res;//_twi_out_buf[_twi_out_len];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUSART0Println(\"F2\");\n\t\t\tsei();\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\t//#if DEBUG == 1\n\t\t\tUSART0Println(\"F3\");\n\t\t//#endif //if DEBUG == 1\n\t\tsei();\n\t\treturn 0;\n\t}\n}\n\n/*\n * Function I2C_BuildPacket\n * Desc     Build initial packet and  prepare buffers for data\n * Input    _addr: slave device addres\n * \t\t\t_mode: what mode will it use(Read or Write)\n * Output   none\n*/\nvoid I2C_BuildPacket(uint8_t _addr, uint8_t _mode)\n{\n\t_twi_in_lens_len++;\n\tI2C_Write((_addr << 1) | (_mode & 1));\n}\n\n\nvoid I2C_BuildRead(uint8_t _addr, uint8_t _len)\n{\n\tI2C_BuildPacket(_addr, I2C_READ);\n\tI2C_Write(_len);\n}\n\n\n\nenum regAddr\n\t{\n\t  SYSRANGE_START                              = 0x00,\n\t  SYSTEM_THRESH_HIGH                          = 0x0C,\n\t  SYSTEM_THRESH_LOW                           = 0x0E,\n\t  SYSTEM_SEQUENCE_CONFIG                      = 0x01,\n\t  SYSTEM_RANGE_CONFIG                         = 0x09,\n\t  SYSTEM_INTERMEASUREMENT_PERIOD              = 0x04,\n\t  SYSTEM_INTERRUPT_CONFIG_GPIO                = 0x0A,\n\t  GPIO_HV_MUX_ACTIVE_HIGH                     = 0x84,\n\t  SYSTEM_INTERRUPT_CLEAR                      = 0x0B,\n\t  RESULT_INTERRUPT_STATUS                     = 0x13,\n\t  RESULT_RANGE_STATUS                         = 0x14,\n\t  RESULT_CORE_AMBIENT_WINDOW_EVENTS_RTN       = 0xBC,\n\t  RESULT_CORE_RANGING_TOTAL_EVENTS_RTN        = 0xC0,\n\t  RESULT_CORE_AMBIENT_WINDOW_EVENTS_REF       = 0xD0,\n\t  RESULT_CORE_RANGING_TOTAL_EVENTS_REF        = 0xD4,\n\t  RESULT_PEAK_SIGNAL_RATE_REF                 = 0xB6,\n\t  ALGO_PART_TO_PART_RANGE_OFFSET_MM           = 0x28,\n\t  I2C_SLAVE_DEVICE_ADDRESS                    = 0x8A,\n\t  MSRC_CONFIG_CONTROL                         = 0x60,\n\t  PRE_RANGE_CONFIG_MIN_SNR                    = 0x27,\n\t  PRE_RANGE_CONFIG_VALID_PHASE_LOW            = 0x56,\n\t  PRE_RANGE_CONFIG_VALID_PHASE_HIGH           = 0x57,\n\t  PRE_RANGE_MIN_COUNT_RATE_RTN_LIMIT          = 0x64,\n\t  FINAL_RANGE_CONFIG_MIN_SNR                  = 0x67,\n\t  FINAL_RANGE_CONFIG_VALID_PHASE_LOW          = 0x47,\n\t  FINAL_RANGE_CONFIG_VALID_PHASE_HIGH         = 0x48,\n\t  FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT = 0x44,\n\t  PRE_RANGE_CONFIG_SIGMA_THRESH_HI            = 0x61,\n\t  PRE_RANGE_CONFIG_SIGMA_THRESH_LO            = 0x62,\n\t  PRE_RANGE_CONFIG_VCSEL_PERIOD               = 0x50,\n\t  PRE_RANGE_CONFIG_TIMEOUT_MACROP_HI          = 0x51,\n\t  PRE_RANGE_CONFIG_TIMEOUT_MACROP_LO          = 0x52,\n\t  SYSTEM_HISTOGRAM_BIN                        = 0x81,\n\t  HISTOGRAM_CONFIG_INITIAL_PHASE_SELECT       = 0x33,\n\t  HISTOGRAM_CONFIG_READOUT_CTRL               = 0x55,\n\t  FINAL_RANGE_CONFIG_VCSEL_PERIOD             = 0x70,\n\t  FINAL_RANGE_CONFIG_TIMEOUT_MACROP_HI        = 0x71,\n\t  FINAL_RANGE_CONFIG_TIMEOUT_MACROP_LO        = 0x72,\n\t  CROSSTALK_COMPENSATION_PEAK_RATE_MCPS       = 0x20,\n\t  MSRC_CONFIG_TIMEOUT_MACROP                  = 0x46,\n\t  SOFT_RESET_GO2_SOFT_RESET_N                 = 0xBF,\n\t  IDENTIFICATION_MODEL_ID                     = 0xC0,\n\t  IDENTIFICATION_REVISION_ID                  = 0xC2,\n\t  OSC_CALIBRATE_VAL                           = 0xF8,\n\t  GLOBAL_CONFIG_VCSEL_WIDTH                   = 0x32,\n\t  GLOBAL_CONFIG_SPAD_ENABLES_REF_0            = 0xB0,\n\t  GLOBAL_CONFIG_SPAD_ENABLES_REF_1            = 0xB1,\n\t  GLOBAL_CONFIG_SPAD_ENABLES_REF_2            = 0xB2,\n\t  GLOBAL_CONFIG_SPAD_ENABLES_REF_3            = 0xB3,\n\t  GLOBAL_CONFIG_SPAD_ENABLES_REF_4            = 0xB4,\n\t  GLOBAL_CONFIG_SPAD_ENABLES_REF_5            = 0xB5,\n\t  GLOBAL_CONFIG_REF_EN_START_SELECT           = 0xB6,\n\t  DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD         = 0x4E,\n\t  DYNAMIC_SPAD_REF_EN_START_OFFSET            = 0x4F,\n\t  POWER_MANAGEMENT_GO1_POWER_FORCE            = 0x80,\n\t  VHV_CONFIG_PAD_SCL_SDA__EXTSUP_HV           = 0x89,\n\t  ALGO_PHASECAL_LIM                           = 0x30,\n\t  ALGO_PHASECAL_CONFIG_TIMEOUT                = 0x30,\n};\n\nISR(TWI_vect)\n{\n\tswitch(TWSR)\n\t{\n\t\tcase 0x00://bus fail\n\t\t{\n\t\t\t\tUSART0Println(\"0x00\");\n\t\t\t#if DEBUG == 1\n\t\t\t#endif //if DEBUG == 1\n\t\t\t_twi_err = 0x01;\n\t\t\t_twi_status = I2C_FAIL;\n\t\t\t_twi_stop();\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x08://start\n\t\t{\n\t\t\t#if DEBUG == 1\n\t\t\t\tUSART0Println(\"0x08\");\n\t\t\t\tUSART0Print(\"M:\");\n\t\t\t\tUSART0Println((char*)((_twi_status == I2C_READ)? \"R\" : \"W\"));\n\t\t\t\tUSART0Println(_twi_initial_packet);\n\t\t\t#endif //if DEBUG == 1\n\t\t\tTWDR = _twi_initial_packet; //send initial packet\n\t\t\t_twi_reply(_TWI_ACK);\t\t//and reply ACK\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x10://reStart\n\t\t{\n\t\t\t\tUSART0Println(\"0x10\");\n\t\t\t#if DEBUG == 1\n\t\t\t#endif //if DEBUG == 1\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x28://byte+ACK\n\t\t{\n\t\t\t#if DEBUG == 1\n\t\t\t\tUSART0Println(\"0x28\");\n\t\t\t#endif //if DEBUG == 1\n\t\t}\n\t\tcase 0x18://SLA+W+ACK\n\t\t{\n\t\t\t#if DEBUG == 1\n\t\t\t\tUSART0Println(\"0x18\");\n\t\t\t\tUSART0Print(\"masl\");\n\t\t\t\tUSART0Println(_twi_master_len);\n\t\t\t\tUSART0Print(\"txl\");\n\t\t\t\tUSART0Println(_twi_tx_len);\n\t\t\t\t\n\t\t\t#endif //if DEBUG == 1\n\t\t\tif(_twi_master_len < _twi_tx_len)\n\t\t\t{\n\t\t\t\t#if DEBUG == 1\n\t\t\t\t\tUSART0Print(\"SEND \");\n\t\t\t\t\tUSART0Println(_twi_master_buf[_twi_master_len]);\n\t\t\t\t\tUSART0Print(\"i:\");\n\t\t\t\t\tUSART0Println(_twi_master_len);\n\t\t\t\t#endif //if DEBUG == 1\n\t\t\t\tTWDR = _twi_master_buf[_twi_master_len];\n\t\t\t\t_twi_master_len++;\n\t\t\t\t_twi_reply(_TWI_ACK);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t#if DEBUG == 1\n\t\t\t\t\tUSART0Println(\"STOP\");\n\t\t\t\t#endif //if DEBUG == 1\n\t\t\t\t_twi_stop();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x20://SLA+W+NACK\n\t\t{\n\t\t\t\tUSART0Println(\"0x20\");\n\t\t\t#if DEBUG == 1\n\t\t\t#endif //if DEBUG == 1\n\t\t\t_twi_err = 0x20;\n\t\t\t_twi_status = I2C_FAIL;\n\t\t\t_twi_stop();\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x30://byte+NACK\n\t\t{\n\t\t\t\tUSART0Println(\"0x30\");\n\t\t\t#if DEBUG == 1\n\t\t\t#endif //if DEBUG == 1\n\t\t\t_twi_err = 0x30;\n\t\t\t_twi_status = I2C_FAIL;\n\t\t\t_twi_stop();\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x38://collision\n\t\t{\n\t\t\t\tUSART0Println(\"0x38\");\n\t\t\t#if DEBUG == 1\n\t\t\t#endif //if DEBUG == 1\n\t\t\t_twi_err = 0x38;\n\t\t\t_twi_status = I2C_FAIL;\n\t\t\t_twi_stop();\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x40://SLA+R+ACK\n\t\t{\n\t\t\t\t//USART0Println(\"0x40\");\n\t\t\t#if DEBUG == 1\n\t\t\t#endif //if DEBUG == 1\n\t\t\tif(_twi_rx_len - _twi_master_len > 1)\n\t\t\t{\n\t\t\t\t_twi_reply(_TWI_ACK);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_twi_reply(_TWI_NACK);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x48://SLA+R+NACK\n\t\t{\n\t\t\t\tUSART0Println(\"0x48\");\n\t\t\t#if DEBUG == 1\n\t\t\t#endif //if DEBUG == 1\n\t\t\t_twi_err = 0x48;\n\t\t\t_twi_status = I2C_FAIL;\n\t\t\t_twi_stop();\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x50://recive byte\n\t\t{\n\t\t\t\t//USART0Println(\"0x50\");\n\t\t\t#if DEBUG == 1\n\t\t\t\tUSART0Print(\"R:\");\n\t\t\t\tUSART0Println(TWDR);\n\t\t\t#endif //if DEBUG == 1\n\t\t\t_twi_master_buf[_twi_master_len] = TWDR;\n\t\t\t_twi_master_len++;\n\t\t\t//_twi_rx_len--;\n\t\t\t\n\t\t\tif(_twi_rx_len - _twi_master_len > 1)\n\t\t\t{\n\t\t\t\t_twi_reply(_TWI_ACK);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_twi_reply(_TWI_NACK);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 0x58://recive byte+NACK\n\t\t{\n\t\t\t\t//USART0Println(\"0x58\");\n\t\t\t#if DEBUG == 1\n\t\t\t\tUSART0Print(\"R:\");\n\t\t\t\tUSART0Println(TWDR);\n\t\t\t\tUSART0Print(\"ml\");\n\t\t\t\tUSART0Println(_twi_master_len);\n\t\t\t#endif //if DEBUG == 1\n\t\t\t_twi_master_buf[_twi_master_len] = TWDR;\n\t\t\t_twi_master_len++;\n\t\t\t_twi_stop();\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t{\n\t\t\tUSART0Print(\"DEFAULT\");\n\t\t\tUSART0Println(TWSR);\n\t\t\t_twi_status = I2C_FAIL;\n\t\t\t_twi_stop();\n\t\t}\n\t}\n}\n\n\nuint8_t readReg(uint8_t _addr, uint8_t _reg)\n{\n\tcli();\n\tuint8_t _res;\n\tI2C_BuildPacket(_addr, I2C_WRITE);\n\tI2C_Write(_reg);\n\t_twi_start();\n\tI2C_BuildRead(_addr, 1);\n\t_twi_start();\n\t_res = I2C_Read();\n\tsei();\n\treturn _res;\n}\n\nuint16_t readReg16B(uint8_t _addr, uint8_t _reg)\n{\n\tcli();\n\tuint16_t _res;\n\tI2C_BuildPacket(_addr, I2C_WRITE);\n\tI2C_Write(_reg);\n\t_twi_start();\n\tI2C_BuildRead(_addr, 2);\n\t_twi_start();\n\tUSART0Println(_twi_out_buf[0]);\n\tUSART0Println(_twi_out_buf[1]);\n\t_res = I2C_Read() << 8;\n\t_res |= I2C_Read();\n\tsei();\n\treturn _res;\n}\n\nvoid writeReg(uint8_t _addr, uint8_t _reg, uint8_t _val)\n{\n\tcli();\n\tI2C_BuildPacket(_addr, I2C_WRITE);\n\tI2C_Write(_reg);\n\tI2C_Write(_val);\n\t_twi_start();\n\tsei();\n}\n\nvoid writeReg16B(uint8_t _addr, uint8_t _reg, uint16_t _val)\n{\n\tcli();\n\tI2C_BuildPacket(_addr, I2C_WRITE);\n\tI2C_Write(_reg);\n\tI2C_Write((_val >> 8) & 0xFF);\n\tI2C_Write(_val & 0xFF);\n\t_twi_start();\n\tsei();\n}\n\nuint64_t millis = 0;\nuint8_t _millis = 0;\n\n\nvoid timerfunc(void)\n{\n\t_millis++;\n\tif(_millis >= 2)\n\t{\n\t\tmillis++;\n\t\t_millis = 0;\n\t}\n\t//USART0Println(\"M\");\n}\n\n\n/*\nvoid setSignalRateLimit(uint8_t _addr, float _lim_mcps)\n{\n\t\n  if (_lim_mcps < 0 || _lim_mcps > 511.99) { return; }\n\n\twriteReg16Bit(_addr, FINAL_RANGE_CONFIG_MIN_COUNT_RATE_RTN_LIMIT, limit_Mcps * (1 << 7));\n\n}\n\n#define calcMacroPeriod(vcsel_period_pclks) ((((uint32_t)2304 * (vcsel_period_pclks) * 1655) + 500) / 1000)\n\nuint32_t timeoutMicrosecondsToMclks(uint32_t timeout_period_us, uint8_t vcsel_period_pclks)\n{\n\tuint32_t macro_period_ns = calcMacroPeriod(vcsel_period_pclks);\n\treturn (((timeout_period_us * 1000) + (macro_period_ns / 2)) / macro_period_ns);\n}\n\nuint16_t encodeTimeout(uint16_t timeout_mclks)\n{\n\t// format: \"(LSByte * 2^MSByte) + 1\"\n\n\tuint32_t ls_byte = 0;\n\tuint16_t ms_byte = 0;\n\n\tif (timeout_mclks > 0)\n\t{\n\t\tls_byte = timeout_mclks - 1;\n\n\t\twhile ((ls_byte & 0xFFFFFF00) > 0)\n\t\t{\n\t\t\tls_byte >>= 1;\n\t\t\tms_byte++;\n\t\t}\n\n\t\treturn (ms_byte << 8) | (ls_byte & 0xFF);\n\t}\n\telse { return 0; }\n}\n\nvoid setMeasurementTimingBudget_us(uint8_t _addr, uint32_t _budget_us)\n{\n\tuint16_t const StartOverhead      = 1320;\n\tuint16_t const EndOverhead        = 960;\n\tuint16_t const MsrcOverhead       = 660;\n\tuint16_t const TccOverhead        = 590;\n\tuint16_t const DssOverhead        = 690;\n\tuint16_t const PreRangeOverhead   = 660;\n\tuint16_t const FinalRangeOverhead = 550;\n\n\tuint32_t const MinTimingBudget = 20000;\n\n\tif (budget_us < MinTimingBudget) { return; }\n\tuint32_t used_budget_us = StartOverhead + EndOverhead;\n}\n\n\nenum vcselPeriodType { VcselPeriodPreRange, VcselPeriodFinalRange };\n\n\nvoid setVcselPulsePeriod (vcselPeriodType type, uint8_t period_pclks)\n{\n\t\n}*/\n\n#define encodeVcselPeriod(period_pclks) (((period_pclks) >> 1) - 1)\n#define ADXL345_DEVICE (0x53)\n\nvoid setRegBit(uint8_t _addr, uint8_t _reg, uint8_t _pos, uint8_t _state)\n{\n\tuint8_t _b = 0;\n\t_b = readReg(_addr, _reg);\n\tif(_state)\n\t{\n\t\t_b |= (1 << _pos);\n\t}\n\telse\n\t{\n\t\t_b &= ~(1 << _pos);\n\t}\n\twriteReg(_addr, _reg, _b);\n}\n\nuint16_t readLen(uint8_t _addr)\n{\n\tuint16_t var;\n\twriteReg(_addr, SYSRANGE_START, 0x01);\n\tdelay(300);\n\tvar = (readReg16B(_addr, RESULT_RANGE_STATUS + 10));\n\twriteReg(_addr, SYSTEM_INTERRUPT_CLEAR, 0x01);\n\treturn var;\n}\n\nint main()\n{\n\tDDRE = 255;\n\tDDRG = 255;\n\tDDRH = 255;\n\tDDRF = 255;\n\tPORTF = 255;\n\tPORTE = 0;\n\t\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tPORTF = (1 << i) | ((1 << i - 1) - 1);\n\t\twriteReg(0x29, 0x8A, 0x29 + i + 1);\n\t}\n\tPORTF = 255;\n\t//PORTF = ~((1 << PF0) | (1 << PF1) | (1 << PF2) | (1 << PF3) | (1 << PF4) | (1 << PF5) | (1 << PF6) | (1 << PF7));\n\t/*PORTE = 0;\n\tdelay(100);\n\tPORTE = 1 << PE4;*/\n\t//srestart();\n\t//PORTD = (1 << PD0) | (1 << PD1);\n\tdelay(100);\n\tsei();\n\tUSART0Begin(115200);\n\tI2C_SetFreq(0x40);\n\t\n\t/*\t\t\t//LB\n\tTCCR3A=(1<<COM3A1)|(1<<WGM30);\n\tTCCR3B=(1<<CS30);\t\n\tOCR3A = 1023;*/\n\t/*\t\t\t//RF\n\tTCCR0A = (1 << COM0B1) | (1 << WGM30);\n\tTCCR0B = (1 << CS00);\n\tOCR0B = 1023;*/\n\t/*\t\t\t//LF\n\tTCCR3A=(1<<COM3C1)|(1<<WGM30);\n\tTCCR3B=(1<<CS30);\t\n\tOCR3C = 1023;*/\n\t/*\t\t\t//RB\n\tTCCR4A=(1<<COM4A1)|(1<<WGM40);\n\tTCCR4B=(1<<CS40);\t\n\tOCR4A = 1023;*/\n\tint var;\n\t\n\tloop:\n\t/*\n\twriteReg(0x29, SYSRANGE_START, 0x01);\n\tdelay(300);\n\tvar = (readReg16B(0x29, RESULT_RANGE_STATUS + 10));\n\twriteReg(0x29, SYSTEM_INTERRUPT_CLEAR, 0x01);\n\t*/\n\t//delay(100);\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tUSART0Println(readLen(0x29));\n\t}\n\tif(I2C_GetError())\n\t{\n\t\tUSART0Println(\"STOP!!!\");\n\t\tUSART0Println(\"IN\");\n\t\tfor(int i = 0; i < _twi_in_len; i++)\n\t\t{\n\t\t\tUSART0Print(i);\n\t\t\tUSART0Send(':');\n\t\t\tUSART0Println(_twi_in_buf[i]);\n\t\t}\n\t\tUSART0Println(\"OUT\");\n\t\tfor(int i = 0; i < _twi_out_len; i++)\n\t\t{\n\t\t\tUSART0Print(i);\n\t\t\tUSART0Send(':');\n\t\t\tUSART0Println(_twi_out_buf[i]);\n\t\t}\n\t\tUSART0Println(\"MAS\");\n\t\tfor(int i = 0; i < _twi_master_len; i++)\n\t\t{\n\t\t\tUSART0Print(i);\n\t\t\tUSART0Send(':');\n\t\t\tUSART0Println(_twi_master_buf[i]);\n\t\t}\n\t\tUSART0Println(\"IN_LENS\");\n\t\tfor(int i = 0; i < _twi_in_lens_len; i++)\n\t\t{\n\t\t\tUSART0Print(i);\n\t\t\tUSART0Send(':');\n\t\t\tUSART0Println(_twi_in_lens_buf[i]);\n\t\t}\n\t\t\n\t\tUSART0Println();\n\t\tUSART0Println(I2C_GetError());\n\t\t//srestart();\n\t\twhile(1);\n\t}\n\t\n\tUSART0Println();\n\tUSART0Println();\n\tgoto loop;\n\n\t//USART0Println(I2C_GetError());\n\t//USART0Println(I2C_Read());\n\twhile(1);\n\treturn 0;\n}\n\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...\nfucking life kills me...",
			"I2C_READ",
			"I2C_Read",
			"\n\t",
			"fucking"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"TIMER",
			"8",
			"7",
			"6",
			"5",
			"__N__",
			"_CLK_SRC_1024",
			"_",
			"TIMER1_WF_FPWM_8B",
			"_WF_FPWM",
			"TIMER",
			" ",
			"8",
			"7",
			"6",
			"5",
			"4",
			"3",
			"2",
			"1",
			"__N__",
			"8",
			"7",
			"6",
			"5",
			"4",
			"3",
			"2",
			"1",
			"_N_",
			"n",
			"B"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "USART.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8030,
						"regions":
						{
						},
						"selection":
						[
							[
								452,
								452
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "main.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 802,
						"regions":
						{
						},
						"selection":
						[
							[
								192,
								192
							]
						],
						"settings":
						{
							"syntax": "Packages/C++11/C++11.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "Timers.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16277,
						"regions":
						{
						},
						"selection":
						[
							[
								13799,
								13799
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.sublime-syntax",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 8996.01196411,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "TimerModes_2560.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31998,
						"regions":
						{
						},
						"selection":
						[
							[
								2693,
								2693
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 566.30109671,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "USART.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1019,
						"regions":
						{
						},
						"selection":
						[
							[
								920,
								920
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 46.8594217348,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 26.9192422732
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": false,
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.exec":
	{
		"height": 115.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 31.0
	},
	"pinned_build_system": "Packages/C++/C++ Single File.sublime-build",
	"project": "avr-api.sublime-project",
	"replace":
	{
		"height": 70.8025922233
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"main",
				"main.cpp"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 501.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/Documents/C++/botFuck/botFuck.sublime-project"
			],
			[
				"togg",
				"~/Documents/C++/glWindow/glWindow.sublime-project"
			],
			[
				"w",
				"~/Documents/C++/wheellib/wheellib.sublime-project"
			],
			[
				"botF",
				"~/Documents/C++/botFuck/botFuck.sublime-project"
			],
			[
				"whee",
				"~/Documents/C++/wheellib/wheellib.sublime-project"
			]
		],
		"width": 381.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 592.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": false,
	"side_bar_width": 186.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
